<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fully Asynchronous 1D CA</title>
  <style>
    :root{
      --bg:#f3f7fb; --panel:#ffffff; --text:#062438; --accent:#0b63d6; --alive:#000066; --dead:#ccffff; --grid:#cbd5e1;
    }
    [data-theme="dark"]{ --bg:#0b1220; --panel:#071029; --text:#dcecf9; --accent:#4aa3ff; --alive:#9ad0ff; --dead:#071029; --grid:#0b2240 }
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--text); margin:16px}
    .app{display:flex; gap:16px; align-items:flex-start}
    .controls{width:360px; background:var(--panel); padding:12px; border-radius:8px; box-shadow:0 6px 18px rgba(2,8,23,0.08)}
    label{display:block; font-size:13px; margin-top:8px}
    input[type=number], input[type=text], select{width:100%; padding:6px 8px; margin-top:6px; border-radius:6px; border:1px solid var(--grid); background:transparent; color:var(--text)}
    .row{display:flex; gap:8px; margin-top:8px}
    button{padding:8px 10px; border-radius:8px; border:none; cursor:pointer; background:var(--accent); color:white}
    button.secondary{background:transparent; color:var(--text); border:1px solid var(--grid)}
    #canvasWrap{background:var(--panel); padding:12px; border-radius:8px}
    canvas{image-rendering:pixelated; display:block; background:var(--dead);}
    .small{font-size:12px; color:gray}
    .legend{display:flex; gap:8px; align-items:center; margin-top:8px}
    .dot{width:14px; height:14px; border-radius:3px}
  </style>
</head>
<body data-theme="light">
  <h2>Fully Asynchronous 1D Cellular Automaton — Simulator</h2>
  <div class="app">
    <div class="controls">
      <label>Cells (n)
        <input id="nInput" type="number" value="30" min="3" max="500">
      </label>
      <label>Rule (0–255)
        <input id="ruleInput" type="number" value="60" min="0" max="255">
      </label>
      <label>Steps (time height)
        <input id="stepsInput" type="number" value="100" min="1" max="1000">
      </label>
      <label>Cell size (px)
        <input id="cellSizeInput" type="number" value="8" min="2" max="32">
      </label>
      <label>Initial configuration (optional binary string — length = n)
        <input id="cfgInput" type="text" placeholder="e.g. 0010101">
      </label>

      <div class="row" style="margin-top:12px">
        <button id="startBtn">Start</button>
        <button id="pauseBtn" class="secondary">Pause</button>
        <button id="stepBtn" class="secondary">Step</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>

      <div class="row" style="margin-top:8px">
        <button id="downloadBtn" class="secondary">Download PNG</button>
        <button id="downloadDataBtn" class="secondary">Download CSV</button>
        <button id="themeBtn" class="secondary">Theme: Light</button>
      </div>

      <div class="legend">
        <div class="dot" style="background:var(--alive)"></div> <div class="small">alive</div>
        <div class="dot" style="background:var(--dead); border:1px solid var(--grid)"></div> <div class="small">dead</div>
      </div>

      <p class="small">Notes: "Fully asynchronous" update picks random sites each micro-step and uses periodic boundary.</p>
    </div>

    <div id="canvasWrap">
      <canvas id="gridCanvas"></canvas>
      <canvas id="chartCanvas" style="margin-top:8px; width:100%; height:120px; border-radius:6px; background:transparent"></canvas>
    </div>
  </div>

  <script>
// Implementation notes:
// - FullyUpdatePeriodic: perform n random single-site updates on copy d from c, using periodic boundaries.
// - The UI controls are applied when Start or Reset pressed. Step advances one time step.

function ruleBitsFromNumber(k){ const R=[]; let kk=k; for(let i=0;i<8;i++){ R.push(kk&1); kk >>=1; } return R; }
function BtoD(arr){ // arr is [left,cur,right]
  return (arr[0]<<2) + (arr[1]<<1) + (arr[2]);
}

function countOnes(arr){ let c=0; for(let v of arr) if(v===1) c++; return c; }

function FullyUpdatePeriodic(c, n, rule){
  // c: array of 0/1 length n
  let d = c.slice();
  const r = rule.slice();
  for(let t=0;t<n;t++){
    const j = Math.floor(Math.random()*n);
    const left = c[(j-1+n)%n];
    const cur = c[j];
    const right = c[(j+1)%n];
    const idx = BtoD([left,cur,right]);
    d[j] = r[idx];
    // copy d into c for next iteration (like original python: c = [k for k in d])
    c = d.slice();
  }
  return d;
}

// draw grid (rows x cols)
function drawGrid(ctx, grid, cellSize, aliveColor, deadColor){
  const rows = grid.length, cols = grid[0].length;
  ctx.canvas.width = cols * cellSize;
  ctx.canvas.height = rows * cellSize;
  ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      ctx.fillStyle = grid[r][c]===1? aliveColor : deadColor;
      ctx.fillRect(c*cellSize, r*cellSize, cellSize-1, cellSize-1);
    }
  }
}

// simple line chart of density (fraction of ones)
function drawChart(ctx, data){
  const w = ctx.canvas.clientWidth; const h = ctx.canvas.clientHeight;
  ctx.canvas.width = w; ctx.canvas.height = h;
  ctx.clearRect(0,0,w,h);
  if(data.length===0) return;
  const maxX = data.length-1;
  ctx.beginPath();
  ctx.lineWidth = 2;
  ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#0b63d6';
  for(let i=0;i<data.length;i++){
    const x = (i/maxX)*w;
    const y = h - data[i]*h;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  // axes
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.font = '12px sans-serif';
  ctx.fillText('Density (fraction of 1s)', 6, 12);
}

// --- App state ---
let grid = null; // 2D array rows x cols
let densities = [];
let running = false;
let timer = null;
let stepIndex = 0;
let Rule = ruleBitsFromNumber(60);

const nInput = document.getElementById('nInput');
const ruleInput = document.getElementById('ruleInput');
const stepsInput = document.getElementById('stepsInput');
const cellSizeInput = document.getElementById('cellSizeInput');
const cfgInput = document.getElementById('cfgInput');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stepBtn = document.getElementById('stepBtn');
const resetBtn = document.getElementById('resetBtn');
const downloadBtn = document.getElementById('downloadBtn');
const downloadDataBtn = document.getElementById('downloadDataBtn');
const themeBtn = document.getElementById('themeBtn');
const gridCanvas = document.getElementById('gridCanvas');
const gridCtx = gridCanvas.getContext('2d');
const chartCanvas = document.getElementById('chartCanvas');
const chartCtx = chartCanvas.getContext('2d');

function prepare(){
  // read parameters and (re)build grid
  const n = Math.max(3, Math.min(500, parseInt(nInput.value)||30));
  const steps = Math.max(1, Math.min(2000, parseInt(stepsInput.value)||100));
  const cellSize = Math.max(2, Math.min(64, parseInt(cellSizeInput.value)||8));
  const k = Math.max(0, Math.min(255, parseInt(ruleInput.value)||60));
  Rule = ruleBitsFromNumber(k);

  const rows = steps+1; const cols = n;
  grid = new Array(rows);
  for(let r=0;r<rows;r++) grid[r] = new Array(cols).fill(0);

  // initial configuration
  const cfg = cfgInput.value.trim();
  if(cfg.length===n && /^[01]+$/.test(cfg)){
    for(let i=0;i<n;i++) grid[0][i] = cfg.charAt(i)==='1'?1:0;
  } else {
    for(let i=0;i<n;i++) grid[0][i] = Math.random()<0.5?1:0;
    cfgInput.value = '';
  }

  densities = [ countOnes(grid[0]) / n ];
  stepIndex = 0;
  drawGrid(gridCtx, grid, cellSize, getComputedStyle(document.body).getPropertyValue('--alive').trim() || '#000066', getComputedStyle(document.body).getPropertyValue('--dead').trim() || '#ccffff');
  drawChart(chartCtx, densities);
}

function tick(){
  if(!grid) return;
  const rows = grid.length; const cols = grid[0].length;
  // compute next row using FullyUpdatePeriodic on current row
  const cur = grid[stepIndex % rows].slice();
  const nxt = FullyUpdatePeriodic(cur, cols, Rule);
  grid[(stepIndex+1) % rows] = nxt.slice();
  stepIndex++;
  densities.push( countOnes(nxt) / cols );
  const cellSize = Math.max(2, Math.min(64, parseInt(cellSizeInput.value)||8));
  drawGrid(gridCtx, grid, cellSize, getComputedStyle(document.body).getPropertyValue('--alive').trim() || '#000066', getComputedStyle(document.body).getPropertyValue('--dead').trim() || '#ccffff');
  drawChart(chartCtx, densities);
}

startBtn.addEventListener('click', ()=>{
  // apply new parameters and start
  prepare();
  if(running) return;
  running = true;
  const fps = 12; timer = setInterval(()=>{ if(running) tick(); if(stepIndex >= grid.length-1) { running=false; clearInterval(timer); } }, 1000/fps);
});
pauseBtn.addEventListener('click', ()=>{
  running = !running;
  if(!running && timer){ clearInterval(timer); timer=null; }
  else if(running && !timer){ const fps=12; timer=setInterval(()=>{ if(running) tick(); if(stepIndex >= grid.length-1) { running=false; clearInterval(timer); } }, 1000/fps); }
});
stepBtn.addEventListener('click', ()=>{ if(!grid) prepare(); tick(); });
resetBtn.addEventListener('click', ()=>{ prepare(); running=false; if(timer){ clearInterval(timer); timer=null;} });

downloadBtn.addEventListener('click', ()=>{
  if(!grid) return;
  // merge gridCanvas and chartCanvas into one image vertically
  const w = gridCanvas.width; const h = gridCanvas.height;
  const cw = chartCanvas.width; const ch = chartCanvas.height;
  const out = document.createElement('canvas'); out.width = Math.max(w,cw); out.height = h + ch;
  const ctx = out.getContext('2d');
  ctx.drawImage(gridCanvas, 0, 0);
  ctx.drawImage(chartCanvas, 0, h);
  const link = document.createElement('a'); link.download = 'fully_async_xca.png'; link.href = out.toDataURL('image/png'); link.click();
});

downloadDataBtn.addEventListener('click', ()=>{
  if(!grid) return;
  // csv: time, density
  let csv = 't,density\n';
  for(let i=0;i<densities.length;i++) csv += `${i},${densities[i]}\n`;
  const blob = new Blob([csv], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='density.csv'; a.click(); URL.revokeObjectURL(url);
});

// theme toggle
const body = document.body; let dark=false;
themeBtn.addEventListener('click', ()=>{ dark=!dark; body.setAttribute('data-theme', dark? 'dark':'light'); themeBtn.textContent = 'Theme: ' + (dark? 'Dark':'Light'); drawGrid(gridCtx, grid || [[]], Math.max(2, Math.min(64, parseInt(cellSizeInput.value)||8)), getComputedStyle(document.body).getPropertyValue('--alive').trim() || '#000066', getComputedStyle(document.body).getPropertyValue('--dead').trim() || '#ccffff'); drawChart(chartCtx,densities); });

// initialize
prepare();

</script>
</body>
</html>